{"version":3,"sources":["TextInputIcon.tsx","enums.tsx","TextInputAffix.tsx","TextInputAdornment.tsx","constants.tsx","InputLabel.tsx","LabelBackground.tsx","helpers.tsx","TextInputOutlined.tsx","TextInputFlat.tsx","TextInput.tsx","AnimatedText.tsx"],"names":["StyleContext","style","isTextInputFocused","forceFocus","IconAdornment","contextState","top","value","TextInputIcon","rest","React","onPressWithFocusControl","forceTextInputFocus","onPress","styles","icon","size","color","StyleSheet","container","position","width","height","justifyContent","alignItems","iconButton","margin","AdornmentType","AdornmentSide","InputMode","AffixContext","textStyle","fontFamily","topPosition","side","Left","AffixAdornment","paddingHorizontal","onLayout","visible","TextInputAffix","theme","textColor","offset","Animated","opacity","inputRange","outputRange","withTheme","getAdornmentConfig","right","adornmentConfig","left","adornment","type","getAdornmentStyleAdjustmentForNativeInput","inputOffset","mode","isLeftSide","inputModeAdornemntOffset","ADORNMENT_OFFSET","paddingKey","captalize","isAffix","marginKey","currentStyle","text","inputAdornmentComponent","commonProps","key","testID","affix","onAffixChange","props","labelBackground","labelTranslationXOffset","labelTranslationX","transform","translateX","parentState","baseLabelTranslateX","labelStyle","fontSize","fontWeight","translateY","baseLabelTranslateY","scale","labelScale","label","pointerEvents","labelProps","paddingOffset","hasActiveOutline","numberOfLines","error","placeholderOpacity","backgroundColor","hasFocus","roundness","useTheme","bottom","Math","scaleY","view","outlinedLabel","calculateLabelTopPosition","optionalPadding","customHeight","calculateInputHeight","finalHeight","calculatePadding","multiline","result","calculateTextAreaPadding","calculateInputPadding","dense","isAndroid","refFontSize","interpolatePlaceholder","labeled","calculateFlatAffixTopPosition","paddingTop","affixHeight","calculateOutlinedIconAndAffixTopPosition","labelYOffset","render","this","font","fonts","colors","viewStyle","fontSizeStyle","inputTextColor","activeColor","placeholderColor","outlineColor","errorColor","fontScale","labelWidth","labelHeight","labelHalfWidth","labelHalfHeight","I18nManager","inputHeight","console","paddingSettings","Platform","pad","paddingOut","paddingBottom","adjustPaddingOut","onLayoutAnimatedText","placeholderStyle","wiggleOffsetX","minHeight","rightLayout","leftAffixTopPosition","leftLayout","rightAffixTopPosition","iconTopPosition","adornmentStyleAdjustmentForNativeInput","rightAffixWidth","leftAffixWidth","affixTopPosition","onRightAffixLayoutChange","adornmentProps","focused","LabelBackground","ref","onChangeText","placeholder","placeholderTextColor","editable","disabled","selectionColor","onFocus","onBlur","underlineColorAndroid","textAlignVertical","textAlign","outline","TextInputOutlined","Outline","borderRadius","borderWidth","borderColor","labelContainer","input","flexGrow","zIndex","inputOutlined","inputOutlinedDense","isPaddingHorizontalPassed","paddingLeft","paddingRight","ADORNMENT_SIZE","calculateFlatInputHorizontalPadding","Flat","underlineColorCustom","underlineColor","containerStyle","borderTopLeftRadius","borderTopRightRadius","minInputHeight","MIN_HEIGHT","paddingFlat","topResult","bottomResult","adjustPaddingFlat","flatHeight","TextInputFlat","Underline","underline","inputFlat","inputFlatDense","labelLayout","measured","clearTimeout","setTimeout","toValue","duration","useNativeDriver","ios","default","event","args","e","componentDidUpdate","isFocusChanged","prevState","state","isValueChanged","isLabelLayoutChanged","isLabelChanged","prevProps","isErrorChanged","minimizeLabel","restoreLabel","showPlaceholder","hidePlaceholder","showError","hideError","componentWillUnmount","setNativeProps","root","isFocused","clear","focus","blur","innerRef","onLeftAffixLayoutChange","nextProps","TextInput","writingDirection"],"mappings":"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","file":"static/js/0.63fd9fa0.chunk.js","sourcesContent":["import React from 'react';\nimport { View, StyleSheet, StyleProp, ViewStyle } from 'react-native';\n\nimport IconButton from '../../IconButton';\nimport type { $Omit } from '../../../../src/types';\nimport type { IconSource } from '../../Icon';\n\ntype Props = $Omit<\n  React.ComponentProps<typeof IconButton>,\n  'icon' | 'theme' | 'color'\n> & {\n  name: IconSource;\n  onPress?: () => void;\n  forceTextInputFocus?: boolean;\n  color?: ((isTextInputFocused: boolean) => string | undefined) | string;\n  style?: StyleProp<ViewStyle>;\n  theme?: ReactNativePaper.Theme;\n};\n\nexport const ICON_SIZE = 24;\nconst ICON_OFFSET = 12;\n\ntype StyleContextType = {\n  style: StyleProp<ViewStyle>;\n  isTextInputFocused: boolean;\n  forceFocus: () => void;\n};\n\nconst StyleContext = React.createContext<StyleContextType>({\n  style: {},\n  isTextInputFocused: false,\n  forceFocus: () => {},\n});\n\nconst IconAdornment: React.FunctionComponent<\n  {\n    testID: string;\n    icon: React.ReactNode;\n    topPosition: number;\n    side: 'left' | 'right';\n  } & Omit<StyleContextType, 'style'>\n> = ({ icon, topPosition, side, isTextInputFocused, forceFocus }) => {\n  const style = {\n    top: topPosition,\n    [side]: ICON_OFFSET,\n  };\n  const contextState = { style, isTextInputFocused, forceFocus };\n\n  return (\n    <StyleContext.Provider value={contextState}>{icon}</StyleContext.Provider>\n  );\n};\n\nconst TextInputIcon = ({\n  name,\n  onPress,\n  forceTextInputFocus,\n  color,\n  ...rest\n}: Props) => {\n  const { style, isTextInputFocused, forceFocus } = React.useContext(\n    StyleContext\n  );\n\n  const onPressWithFocusControl = React.useCallback(() => {\n    if (forceTextInputFocus && !isTextInputFocused) {\n      forceFocus();\n    }\n    onPress?.();\n  }, [forceTextInputFocus, forceFocus, isTextInputFocused, onPress]);\n\n  return (\n    <View style={[styles.container, style]}>\n      <IconButton\n        icon={name}\n        style={styles.iconButton}\n        size={ICON_SIZE}\n        onPress={onPressWithFocusControl}\n        color={typeof color === 'function' ? color(isTextInputFocused) : color}\n        {...rest}\n      />\n    </View>\n  );\n};\nTextInputIcon.displayName = 'TextInput.Icon';\n\nTextInputIcon.defaultProps = {\n  forceTextInputFocus: true,\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    position: 'absolute',\n    width: ICON_SIZE,\n    height: ICON_SIZE,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  iconButton: {\n    margin: 0,\n  },\n});\n\nexport default TextInputIcon;\n\n// @component-docs ignore-next-line\nexport { IconAdornment };\n","export enum AdornmentType {\n  Icon = 'icon',\n  Affix = 'affix',\n}\nexport enum AdornmentSide {\n  Right = 'right',\n  Left = 'left',\n}\nexport enum InputMode {\n  Outlined = 'outlined',\n  Flat = 'flat',\n}\n","import React from 'react';\nimport color from 'color';\nimport {\n  Text,\n  StyleSheet,\n  StyleProp,\n  TextStyle,\n  LayoutChangeEvent,\n  Animated,\n  ViewStyle,\n} from 'react-native';\n\nimport { withTheme } from '../../../core/theming';\nimport { AdornmentSide } from './enums';\n\nconst AFFIX_OFFSET = 12;\n\ntype Props = {\n  text: string;\n  onLayout?: (event: LayoutChangeEvent) => void;\n  textStyle?: StyleProp<TextStyle>;\n  /**\n   * @optional\n   */\n  theme: ReactNativePaper.Theme;\n};\n\ntype ContextState = {\n  topPosition: number | null;\n  onLayout?: (event: LayoutChangeEvent) => void;\n  visible?: Animated.Value;\n  textStyle?: StyleProp<TextStyle>;\n  side: AdornmentSide;\n  paddingHorizontal?: number | string;\n};\n\nconst AffixContext = React.createContext<ContextState>({\n  textStyle: { fontFamily: '', color: '' },\n  topPosition: null,\n  side: AdornmentSide.Left,\n});\n\nconst AffixAdornment: React.FunctionComponent<\n  {\n    affix: React.ReactNode;\n    testID: string;\n  } & ContextState\n> = ({\n  affix,\n  side,\n  textStyle,\n  topPosition,\n  onLayout,\n  visible,\n  paddingHorizontal,\n}) => {\n  return (\n    <AffixContext.Provider\n      value={{\n        side,\n        textStyle,\n        topPosition,\n        onLayout,\n        visible,\n        paddingHorizontal,\n      }}\n    >\n      {affix}\n    </AffixContext.Provider>\n  );\n};\n\nconst TextInputAffix = ({ text, textStyle: labelStyle, theme }: Props) => {\n  const {\n    textStyle,\n    onLayout,\n    topPosition,\n    side,\n    visible,\n    paddingHorizontal,\n  } = React.useContext(AffixContext);\n  const textColor = color(theme.colors.text)\n    .alpha(theme.dark ? 0.7 : 0.54)\n    .rgb()\n    .string();\n\n  const offset =\n    typeof paddingHorizontal === 'number' ? paddingHorizontal : AFFIX_OFFSET;\n\n  const style = {\n    top: topPosition,\n    [side]: offset,\n  } as ViewStyle;\n\n  return (\n    <Animated.View\n      style={[\n        styles.container,\n        style,\n        {\n          opacity:\n            visible?.interpolate({\n              inputRange: [0, 1],\n              outputRange: [1, 0],\n            }) || 1,\n        },\n      ]}\n      onLayout={onLayout}\n    >\n      <Text style={[{ color: textColor }, textStyle, labelStyle]}>{text}</Text>\n    </Animated.View>\n  );\n};\nTextInputAffix.displayName = 'TextInput.Affix';\n\nconst styles = StyleSheet.create({\n  container: {\n    position: 'absolute',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n\nexport default withTheme(TextInputAffix);\n\n// @component-docs ignore-next-line\nexport { TextInputAffix, AffixAdornment };\n","import React from 'react';\nimport TextInputIcon, { IconAdornment } from './TextInputIcon';\nimport TextInputAffix, { AffixAdornment } from './TextInputAffix';\nimport { ADORNMENT_OFFSET, OUTLINED_INPUT_OFFSET } from '../constants';\nimport type {\n  LayoutChangeEvent,\n  TextStyle,\n  StyleProp,\n  Animated,\n} from 'react-native';\nimport type {\n  AdornmentConfig,\n  AdornmentStyleAdjustmentForNativeInput,\n} from './types';\nimport { AdornmentSide, AdornmentType, InputMode } from './enums';\n\nexport function getAdornmentConfig({\n  left,\n  right,\n}: {\n  left?: React.ReactNode;\n  right?: React.ReactNode;\n}): Array<AdornmentConfig> {\n  let adornmentConfig: any[] = [];\n  if (left || right) {\n    [\n      { side: AdornmentSide.Left, adornment: left },\n      { side: AdornmentSide.Right, adornment: right },\n    ].forEach(({ side, adornment }) => {\n      if (adornment && React.isValidElement(adornment)) {\n        let type;\n        if (adornment.type === TextInputAffix) {\n          type = AdornmentType.Affix;\n        } else if (adornment.type === TextInputIcon) {\n          type = AdornmentType.Icon;\n        }\n        adornmentConfig.push({\n          side,\n          type,\n        });\n      }\n    });\n  }\n\n  return adornmentConfig;\n}\n\nexport function getAdornmentStyleAdjustmentForNativeInput({\n  adornmentConfig,\n  leftAffixWidth,\n  rightAffixWidth,\n  paddingHorizontal,\n  inputOffset = 0,\n  mode,\n}: {\n  inputOffset?: number;\n  adornmentConfig: AdornmentConfig[];\n  leftAffixWidth: number;\n  rightAffixWidth: number;\n  mode?: 'outlined' | 'flat';\n  paddingHorizontal?: number | string;\n}): AdornmentStyleAdjustmentForNativeInput | {} {\n  if (adornmentConfig.length) {\n    const adornmentStyleAdjustmentForNativeInput = adornmentConfig.map(\n      ({ type, side }: AdornmentConfig) => {\n        const isLeftSide = side === AdornmentSide.Left;\n        const inputModeAdornemntOffset =\n          mode === InputMode.Outlined\n            ? ADORNMENT_OFFSET + OUTLINED_INPUT_OFFSET\n            : ADORNMENT_OFFSET;\n        const paddingKey = `padding${captalize(side)}`;\n        const affixWidth = isLeftSide ? leftAffixWidth : rightAffixWidth;\n        const padding =\n          typeof paddingHorizontal === 'number'\n            ? paddingHorizontal\n            : inputModeAdornemntOffset;\n        const offset = affixWidth + padding;\n\n        const isAffix = type === AdornmentType.Affix;\n        const marginKey = `margin${captalize(side)}`;\n\n        return {\n          [marginKey]: isAffix ? 0 : offset,\n          [paddingKey]: isAffix ? offset : inputOffset,\n        };\n      }\n    );\n    const allStyleAdjustmentsMerged = adornmentStyleAdjustmentForNativeInput.reduce(\n      (mergedStyles, currentStyle) => {\n        return {\n          ...mergedStyles,\n          ...currentStyle,\n        };\n      },\n      {}\n    );\n    return allStyleAdjustmentsMerged;\n  } else {\n    return [{}];\n  }\n}\n\nconst captalize = (text: string) =>\n  text.charAt(0).toUpperCase() + text.slice(1);\n\nexport interface TextInputAdornmentProps {\n  forceFocus: () => void;\n  adornmentConfig: AdornmentConfig[];\n  topPosition: {\n    [AdornmentType.Affix]: {\n      [AdornmentSide.Left]: number | null;\n      [AdornmentSide.Right]: number | null;\n    };\n    [AdornmentType.Icon]: number;\n  };\n  onAffixChange: {\n    [AdornmentSide.Left]: (event: LayoutChangeEvent) => void;\n    [AdornmentSide.Right]: (event: LayoutChangeEvent) => void;\n  };\n  left?: React.ReactNode;\n  right?: React.ReactNode;\n  textStyle?: StyleProp<TextStyle>;\n  visible?: Animated.Value;\n  isTextInputFocused: boolean;\n  paddingHorizontal?: number | string;\n}\n\nconst TextInputAdornment: React.FunctionComponent<TextInputAdornmentProps> = ({\n  adornmentConfig,\n  left,\n  right,\n  onAffixChange,\n  textStyle,\n  visible,\n  topPosition,\n  isTextInputFocused,\n  forceFocus,\n  paddingHorizontal,\n}) => {\n  if (adornmentConfig.length) {\n    return (\n      <>\n        {adornmentConfig.map(({ type, side }: AdornmentConfig) => {\n          let inputAdornmentComponent;\n          if (side === AdornmentSide.Left) {\n            inputAdornmentComponent = left;\n          } else if (side === AdornmentSide.Right) {\n            inputAdornmentComponent = right;\n          }\n\n          const commonProps = {\n            key: side,\n            side: side,\n            testID: `${side}-${type}-adornment`,\n            isTextInputFocused,\n            paddingHorizontal,\n          };\n          if (type === AdornmentType.Icon) {\n            return (\n              <IconAdornment\n                {...commonProps}\n                icon={inputAdornmentComponent}\n                topPosition={topPosition[AdornmentType.Icon]}\n                forceFocus={forceFocus}\n              />\n            );\n          } else if (type === AdornmentType.Affix) {\n            return (\n              <AffixAdornment\n                {...commonProps}\n                topPosition={topPosition[AdornmentType.Affix][side]}\n                affix={inputAdornmentComponent}\n                textStyle={textStyle}\n                onLayout={onAffixChange[side]}\n                visible={visible}\n              />\n            );\n          } else {\n            return null;\n          }\n        })}\n      </>\n    );\n  } else {\n    return null;\n  }\n};\n\nexport default TextInputAdornment;\n","export const MAXIMIZED_LABEL_FONT_SIZE = 16;\nexport const MINIMIZED_LABEL_FONT_SIZE = 12;\nexport const LABEL_WIGGLE_X_OFFSET = 4;\nexport const LABEL_PADDING_HORIZONTAL = 12;\nexport const ADORNMENT_SIZE = 24;\nexport const ADORNMENT_OFFSET = 12;\nexport const FLAT_INPUT_OFFSET = 8;\n// extra space to avoid overlapping input's text and icon\nexport const OUTLINED_INPUT_OFFSET = 8;\n","import React from 'react';\nimport { Animated, StyleSheet } from 'react-native';\nimport AnimatedText from '../../Typography/AnimatedText';\n\nimport type { InputLabelProps } from '../types';\n\nconst InputLabel = (props: InputLabelProps) => {\n  const { parentState, labelBackground } = props;\n\n  const {\n    label,\n    error,\n    onLayoutAnimatedText,\n    hasActiveOutline,\n    activeColor,\n    placeholderStyle,\n    baseLabelTranslateX,\n    baseLabelTranslateY,\n    font,\n    fontSize,\n    fontWeight,\n    placeholderOpacity,\n    wiggleOffsetX,\n    labelScale,\n    topPosition,\n    paddingOffset,\n    placeholderColor,\n    errorColor,\n    labelTranslationXOffset,\n  } = props.labelProps;\n\n  const labelTranslationX = {\n    transform: [\n      {\n        // Offset label scale since RN doesn't support transform origin\n        translateX: parentState.labeled.interpolate({\n          inputRange: [0, 1],\n          outputRange: [baseLabelTranslateX, labelTranslationXOffset || 0],\n        }),\n      },\n    ],\n  };\n\n  const labelStyle = {\n    ...font,\n    fontSize,\n    fontWeight,\n    transform: [\n      {\n        // Wiggle the label when there's an error\n        translateX: parentState.error.interpolate({\n          inputRange: [0, 0.5, 1],\n          outputRange: [0, parentState.value && error ? wiggleOffsetX : 0, 0],\n        }),\n      },\n      {\n        // Move label to top\n        translateY: parentState.labeled.interpolate({\n          inputRange: [0, 1],\n          outputRange: [baseLabelTranslateY, 0],\n        }),\n      },\n      {\n        // Make label smaller\n        scale: parentState.labeled.interpolate({\n          inputRange: [0, 1],\n          outputRange: [labelScale, 1],\n        }),\n      },\n    ],\n  };\n\n  return label ? (\n    // Position colored placeholder and gray placeholder on top of each other and crossfade them\n    // This gives the effect of animating the color, but allows us to use native driver\n    <Animated.View\n      pointerEvents=\"none\"\n      style={[\n        StyleSheet.absoluteFill,\n        {\n          opacity:\n            // Hide the label in minimized state until we measure it's width\n            parentState.value || parentState.focused\n              ? parentState.labelLayout.measured\n                ? 1\n                : 0\n              : 1,\n        },\n        labelTranslationX,\n      ]}\n    >\n      {labelBackground?.({\n        parentState,\n        labelStyle,\n        labelProps: props.labelProps,\n      })}\n      <AnimatedText\n        onLayout={onLayoutAnimatedText}\n        style={[\n          placeholderStyle,\n          {\n            top: topPosition,\n          },\n          labelStyle,\n          paddingOffset || {},\n          {\n            color: activeColor,\n            opacity: parentState.labeled.interpolate({\n              inputRange: [0, 1],\n              outputRange: [hasActiveOutline ? 1 : 0, 0],\n            }),\n          },\n        ]}\n        numberOfLines={1}\n      >\n        {label}\n      </AnimatedText>\n      <AnimatedText\n        style={[\n          placeholderStyle,\n          {\n            top: topPosition,\n          },\n          labelStyle,\n          paddingOffset,\n          {\n            color: error && errorColor ? errorColor : placeholderColor,\n            opacity: placeholderOpacity,\n          },\n        ]}\n        numberOfLines={1}\n      >\n        {label}\n      </AnimatedText>\n    </Animated.View>\n  ) : null;\n};\n\nexport default InputLabel;\n","import * as React from 'react';\nimport { Animated, StyleSheet } from 'react-native';\n\nimport AnimatedText from '../../Typography/AnimatedText';\nimport { useTheme } from '../../../core/theming';\n\nimport type { LabelBackgroundProps } from '../types';\n\nconst LabelBackground = ({\n  parentState,\n  labelProps: {\n    placeholderStyle,\n    baseLabelTranslateX,\n    topPosition,\n    hasActiveOutline,\n    label,\n    backgroundColor,\n  },\n  labelStyle,\n}: LabelBackgroundProps) => {\n  const hasFocus = hasActiveOutline || parentState.value;\n  const opacity = parentState.labeled.interpolate({\n    inputRange: [0, 1],\n    outputRange: [hasFocus ? 1 : 0, 0],\n  });\n  const { roundness } = useTheme();\n\n  const labelTranslationX = {\n    transform: [\n      {\n        translateX: parentState.labeled.interpolate({\n          inputRange: [0, 1],\n          outputRange: [-baseLabelTranslateX, 0],\n        }),\n      },\n    ],\n  };\n\n  return label\n    ? [\n        <Animated.View\n          key=\"labelBackground-view\"\n          pointerEvents=\"none\"\n          style={[\n            StyleSheet.absoluteFill,\n            styles.view,\n            {\n              backgroundColor,\n              opacity,\n              bottom: Math.max(roundness, 2),\n            },\n            labelTranslationX,\n          ]}\n        />,\n        <AnimatedText\n          key=\"labelBackground-text\"\n          style={[\n            placeholderStyle,\n            labelStyle,\n            styles.outlinedLabel,\n            {\n              top: topPosition + 1,\n              backgroundColor,\n              opacity,\n              transform: [\n                ...labelStyle.transform,\n                {\n                  scaleY: parentState.labeled.interpolate({\n                    inputRange: [0, 1],\n                    outputRange: [0.2, 1],\n                  }),\n                },\n              ],\n            },\n          ]}\n          numberOfLines={1}\n        >\n          {label}\n        </AnimatedText>,\n      ]\n    : null;\n};\n\nexport default LabelBackground;\n\nconst styles = StyleSheet.create({\n  view: {\n    position: 'absolute',\n    top: 6,\n    left: 10,\n    width: 8,\n  },\n  outlinedLabel: {\n    position: 'absolute',\n    left: 18,\n    paddingHorizontal: 0,\n    color: 'transparent',\n  },\n});\n","import type { Animated } from 'react-native';\nimport type { AdornmentConfig } from './Adornment/types';\nimport {\n  LABEL_PADDING_HORIZONTAL,\n  ADORNMENT_OFFSET,\n  ADORNMENT_SIZE,\n  FLAT_INPUT_OFFSET,\n} from './constants';\nimport { AdornmentType, AdornmentSide } from './Adornment/enums';\n\ntype PaddingProps = {\n  height: number | null;\n  labelHalfHeight: number;\n  multiline: boolean | null;\n  dense: boolean | null;\n  topPosition: number;\n  fontSize: number;\n  label?: string | null;\n  scale: number;\n  offset: number;\n  isAndroid: boolean;\n  styles: { paddingTop: number; paddingBottom: number };\n};\n\ntype AdjProps = PaddingProps & {\n  pad: number;\n};\n\nexport type Padding = { paddingTop: number; paddingBottom: number };\n\nexport const calculateLabelTopPosition = (\n  labelHeight: number,\n  height: number = 0,\n  optionalPadding: number = 0\n): number => {\n  const customHeight = height > 0 ? height : 0;\n\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\n\nexport const calculateInputHeight = (\n  labelHeight: number,\n  height: any = 0,\n  minHeight: number\n): number => {\n  const finalHeight = height > 0 ? height : labelHeight;\n\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\n\nexport const calculatePadding = (props: PaddingProps): number => {\n  const { height, multiline = false } = props;\n\n  let result = 0;\n\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n\n  return Math.max(0, result);\n};\n\nconst calculateTextAreaPadding = (props: PaddingProps) => {\n  const { dense } = props;\n\n  return dense ? 10 : 20;\n};\n\nconst calculateInputPadding = ({\n  topPosition,\n  fontSize,\n  multiline,\n  scale,\n  dense,\n  offset,\n  isAndroid,\n}: PaddingProps): number => {\n  const refFontSize = scale * fontSize;\n  let result = Math.floor(topPosition / 2);\n\n  result =\n    result +\n    Math.floor((refFontSize - fontSize) / 2) -\n    (scale < 1 ? offset / 2 : 0);\n\n  if (multiline && isAndroid)\n    result = Math.min(dense ? offset / 2 : offset, result);\n\n  return result;\n};\n\nexport const adjustPaddingOut = ({\n  pad,\n  multiline,\n  label,\n  scale,\n  height,\n  fontSize,\n  dense,\n  offset,\n  isAndroid,\n}: AdjProps): Padding => {\n  const refFontSize = scale * fontSize;\n  let result = pad;\n\n  if (height) {\n    return {\n      paddingTop: Math.max(0, (height - fontSize) / 2),\n      paddingBottom: Math.max(0, (height - fontSize) / 2),\n    };\n  }\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, (refFontSize / 2) * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n    if (!dense) {\n      if (label) {\n        result +=\n          scale < 1\n            ? Math.min(offset, refFontSize * scale)\n            : Math.min(offset / 2, refFontSize * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontSize * scale) : 0;\n      }\n    }\n    result = Math.floor(result);\n  }\n  return { paddingTop: result, paddingBottom: result };\n};\n\nexport const adjustPaddingFlat = ({\n  pad,\n  scale,\n  multiline,\n  label,\n  height,\n  offset,\n  dense,\n  fontSize,\n  isAndroid,\n  styles,\n}: AdjProps): Padding => {\n  let result = pad;\n  let topResult = result;\n  let bottomResult = result;\n  const { paddingTop, paddingBottom } = styles;\n  const refFontSize = scale * fontSize;\n\n  if (!multiline) {\n    // do not modify padding if input is not multiline\n    if (label) {\n      // return const style for flat input with label\n      return { paddingTop, paddingBottom };\n    }\n    // return pad for flat input without label\n    return { paddingTop: result, paddingBottom: result };\n  }\n\n  if (label) {\n    // add paddings passed from styles\n    topResult = paddingTop;\n    bottomResult = paddingBottom;\n\n    // adjust top padding for iOS\n    if (!isAndroid) {\n      if (dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(result, refFontSize * scale) - result / 2\n            : Math.min(result, refFontSize * scale) - result / 2;\n      }\n      if (!dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(offset / 2, refFontSize * scale)\n            : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      // center text when height is passed\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2),\n      };\n    }\n    // adjust paddings for iOS if no label\n    if (!isAndroid) {\n      if (dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset / 2, (fontSize / 2) * scale)\n            : Math.min(offset / 2, scale);\n      }\n      if (!dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset, fontSize * scale)\n            : Math.min(fontSize, (offset / 2) * scale);\n      }\n\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult),\n  };\n};\n\nexport const interpolatePlaceholder = (\n  labeled: Animated.Value,\n  hasActiveOutline: boolean | undefined\n) =>\n  labeled.interpolate({\n    inputRange: [0, 1],\n    outputRange: [hasActiveOutline ? 0 : 1, 1],\n  });\n\nexport function calculateFlatAffixTopPosition({\n  height,\n  paddingTop,\n  paddingBottom,\n  affixHeight,\n}: {\n  height: number;\n  paddingTop: number;\n  paddingBottom: number;\n  affixHeight: number;\n}): number {\n  const inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n\n  const halfOfTheInputHeightDecreasedByAffixHeight =\n    (inputHeightWithoutPadding - affixHeight) / 2;\n\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\n\nexport function calculateOutlinedIconAndAffixTopPosition({\n  height,\n  affixHeight,\n  labelYOffset,\n}: {\n  height: number;\n  affixHeight: number;\n  labelYOffset: number;\n}): number {\n  return (height - affixHeight + labelYOffset) / 2;\n}\n\nexport const calculateFlatInputHorizontalPadding = ({\n  adornmentConfig,\n}: {\n  adornmentConfig: AdornmentConfig[];\n}) => {\n  let paddingLeft = LABEL_PADDING_HORIZONTAL;\n  let paddingRight = LABEL_PADDING_HORIZONTAL;\n\n  adornmentConfig.forEach(({ type, side }) => {\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n\n  return { paddingLeft, paddingRight };\n};\n","import * as React from 'react';\nimport {\n  View,\n  TextInput as NativeTextInput,\n  StyleSheet,\n  I18nManager,\n  Platform,\n  TextStyle,\n  ColorValue,\n} from 'react-native';\nimport color from 'color';\nimport TextInputAdornment, {\n  getAdornmentConfig,\n  getAdornmentStyleAdjustmentForNativeInput,\n  TextInputAdornmentProps,\n} from './Adornment/TextInputAdornment';\n\nimport InputLabel from './Label/InputLabel';\nimport LabelBackground from './Label/LabelBackground';\nimport type { RenderProps, ChildTextInputProps } from './types';\n\nimport {\n  MAXIMIZED_LABEL_FONT_SIZE,\n  MINIMIZED_LABEL_FONT_SIZE,\n  LABEL_WIGGLE_X_OFFSET,\n  ADORNMENT_SIZE,\n  ADORNMENT_OFFSET,\n} from './constants';\n\nimport {\n  calculateLabelTopPosition,\n  calculateInputHeight,\n  calculatePadding,\n  adjustPaddingOut,\n  Padding,\n  interpolatePlaceholder,\n  calculateOutlinedIconAndAffixTopPosition,\n} from './helpers';\nimport { AdornmentType, AdornmentSide } from './Adornment/enums';\n\nconst OUTLINE_MINIMIZED_LABEL_Y_OFFSET = -6;\nconst LABEL_PADDING_TOP = 8;\nconst MIN_HEIGHT = 64;\nconst MIN_DENSE_HEIGHT = 48;\nconst INPUT_PADDING_HORIZONTAL = 14;\n\nclass TextInputOutlined extends React.Component<ChildTextInputProps> {\n  static defaultProps = {\n    disabled: false,\n    error: false,\n    multiline: false,\n    editable: true,\n    render: (props: RenderProps) => <NativeTextInput {...props} />,\n  };\n\n  render() {\n    const {\n      disabled,\n      editable,\n      label,\n      error,\n      selectionColor,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      underlineColor,\n      dense,\n      style,\n      theme,\n      render,\n      multiline,\n      parentState,\n      innerRef,\n      onFocus,\n      forceFocus,\n      onBlur,\n      onChangeText,\n      onLayoutAnimatedText,\n      onLeftAffixLayoutChange,\n      onRightAffixLayoutChange,\n      left,\n      right,\n      placeholderTextColor,\n      ...rest\n    } = this.props;\n\n    const adornmentConfig = getAdornmentConfig({ left, right });\n\n    const { colors, fonts } = theme;\n    const font = fonts.regular;\n    const hasActiveOutline = parentState.focused || error;\n\n    const {\n      fontSize: fontSizeStyle,\n      fontWeight,\n      height,\n      backgroundColor = colors.background,\n      textAlign,\n      ...viewStyle\n    } = (StyleSheet.flatten(style) || {}) as TextStyle;\n    const fontSize = fontSizeStyle || MAXIMIZED_LABEL_FONT_SIZE;\n\n    let inputTextColor, activeColor, outlineColor, placeholderColor, errorColor;\n\n    if (disabled) {\n      inputTextColor = activeColor = color(colors.text)\n        .alpha(0.54)\n        .rgb()\n        .string();\n      placeholderColor = outlineColor = colors.disabled;\n    } else {\n      inputTextColor = colors.text;\n      activeColor = error ? colors.error : colors.primary;\n      placeholderColor = outlineColor = colors.placeholder;\n      errorColor = colors.error;\n    }\n\n    const labelScale = MINIMIZED_LABEL_FONT_SIZE / fontSize;\n    const fontScale = MAXIMIZED_LABEL_FONT_SIZE / fontSize;\n\n    const labelWidth = parentState.labelLayout.width;\n    const labelHeight = parentState.labelLayout.height;\n    const labelHalfWidth = labelWidth / 2;\n    const labelHalfHeight = labelHeight / 2;\n\n    const baseLabelTranslateX =\n      (I18nManager.isRTL ? 1 : -1) *\n      (labelHalfWidth -\n        (labelScale * labelWidth) / 2 -\n        (fontSize - MINIMIZED_LABEL_FONT_SIZE) * labelScale);\n\n    let labelTranslationXOffset = 0;\n    const isAdornmentLeftIcon = adornmentConfig.some(\n      ({ side, type }) =>\n        side === AdornmentSide.Left && type === AdornmentType.Icon\n    );\n    if (isAdornmentLeftIcon) {\n      labelTranslationXOffset =\n        (I18nManager.isRTL ? -1 : 1) * (ADORNMENT_SIZE + ADORNMENT_OFFSET - 8);\n    }\n\n    const minInputHeight =\n      (dense ? MIN_DENSE_HEIGHT : MIN_HEIGHT) - LABEL_PADDING_TOP;\n\n    const inputHeight = calculateInputHeight(\n      labelHeight,\n      height,\n      minInputHeight\n    );\n\n    const topPosition = calculateLabelTopPosition(\n      labelHeight,\n      inputHeight,\n      LABEL_PADDING_TOP\n    );\n\n    if (height && typeof height !== 'number') {\n      // eslint-disable-next-line\n      console.warn('Currently we support only numbers in height prop');\n    }\n\n    const paddingSettings = {\n      height: height ? +height : null,\n      labelHalfHeight,\n      offset: LABEL_PADDING_TOP,\n      multiline: multiline ? multiline : null,\n      dense: dense ? dense : null,\n      topPosition,\n      fontSize,\n      label,\n      scale: fontScale,\n      isAndroid: Platform.OS === 'android',\n      styles: StyleSheet.flatten(\n        dense ? styles.inputOutlinedDense : styles.inputOutlined\n      ) as Padding,\n    };\n\n    const pad = calculatePadding(paddingSettings);\n\n    const paddingOut = adjustPaddingOut({ ...paddingSettings, pad });\n\n    const baseLabelTranslateY =\n      -labelHalfHeight - (topPosition + OUTLINE_MINIMIZED_LABEL_Y_OFFSET);\n\n    const placeholderOpacity = hasActiveOutline\n      ? interpolatePlaceholder(parentState.labeled, hasActiveOutline)\n      : parentState.labelLayout.measured\n      ? 1\n      : 0;\n\n    const labelProps = {\n      label,\n      onLayoutAnimatedText,\n      placeholderOpacity,\n      error,\n      placeholderStyle: styles.placeholder,\n      baseLabelTranslateY,\n      baseLabelTranslateX,\n      font,\n      fontSize,\n      fontWeight,\n      labelScale,\n      wiggleOffsetX: LABEL_WIGGLE_X_OFFSET,\n      topPosition,\n      hasActiveOutline,\n      activeColor,\n      placeholderColor,\n      backgroundColor: backgroundColor as ColorValue,\n      errorColor,\n      labelTranslationXOffset,\n    };\n\n    const minHeight = (height ||\n      (dense ? MIN_DENSE_HEIGHT : MIN_HEIGHT)) as number;\n\n    const { leftLayout, rightLayout } = parentState;\n\n    const leftAffixTopPosition = calculateOutlinedIconAndAffixTopPosition({\n      height: minHeight,\n      affixHeight: leftLayout.height || 0,\n      labelYOffset: -OUTLINE_MINIMIZED_LABEL_Y_OFFSET,\n    });\n\n    const rightAffixTopPosition = calculateOutlinedIconAndAffixTopPosition({\n      height: minHeight,\n      affixHeight: rightLayout.height || 0,\n      labelYOffset: -OUTLINE_MINIMIZED_LABEL_Y_OFFSET,\n    });\n    const iconTopPosition = calculateOutlinedIconAndAffixTopPosition({\n      height: minHeight,\n      affixHeight: ADORNMENT_SIZE,\n      labelYOffset: -OUTLINE_MINIMIZED_LABEL_Y_OFFSET,\n    });\n\n    const rightAffixWidth = right\n      ? rightLayout.width || ADORNMENT_SIZE\n      : ADORNMENT_SIZE;\n\n    const leftAffixWidth = left\n      ? leftLayout.width || ADORNMENT_SIZE\n      : ADORNMENT_SIZE;\n\n    const adornmentStyleAdjustmentForNativeInput = getAdornmentStyleAdjustmentForNativeInput(\n      {\n        adornmentConfig,\n        rightAffixWidth,\n        leftAffixWidth,\n        mode: 'outlined',\n      }\n    );\n    const affixTopPosition = {\n      [AdornmentSide.Left]: leftAffixTopPosition,\n      [AdornmentSide.Right]: rightAffixTopPosition,\n    };\n    const onAffixChange = {\n      [AdornmentSide.Left]: onLeftAffixLayoutChange,\n      [AdornmentSide.Right]: onRightAffixLayoutChange,\n    };\n\n    let adornmentProps: TextInputAdornmentProps = {\n      adornmentConfig,\n      forceFocus,\n      topPosition: {\n        [AdornmentType.Icon]: iconTopPosition,\n        [AdornmentType.Affix]: affixTopPosition,\n      },\n      onAffixChange,\n      isTextInputFocused: parentState.focused,\n    };\n    if (adornmentConfig.length) {\n      adornmentProps = {\n        ...adornmentProps,\n        left,\n        right,\n        textStyle: { ...font, fontSize, fontWeight },\n        visible: this.props.parentState.labeled,\n      };\n    }\n\n    return (\n      <View style={viewStyle}>\n        {/*\n          Render the outline separately from the container\n          This is so that the label can overlap the outline\n          Otherwise the border will cut off the label on Android\n          */}\n        <View>\n          <Outline\n            theme={theme}\n            hasActiveOutline={hasActiveOutline}\n            activeColor={activeColor}\n            outlineColor={outlineColor}\n            backgroundColor={backgroundColor}\n          />\n          <View\n            style={[\n              styles.labelContainer,\n              {\n                paddingTop: LABEL_PADDING_TOP,\n                minHeight,\n              },\n            ]}\n          >\n            <InputLabel\n              parentState={parentState}\n              labelProps={labelProps}\n              labelBackground={LabelBackground}\n            />\n            {render?.({\n              ...rest,\n              ref: innerRef,\n              onChangeText,\n              placeholder: label\n                ? parentState.placeholder\n                : this.props.placeholder,\n              placeholderTextColor: placeholderTextColor || placeholderColor,\n              editable: !disabled && editable,\n              selectionColor:\n                typeof selectionColor === 'undefined'\n                  ? activeColor\n                  : selectionColor,\n              onFocus,\n              onBlur,\n              underlineColorAndroid: 'transparent',\n              multiline,\n              style: [\n                styles.input,\n                !multiline || (multiline && height)\n                  ? { height: inputHeight }\n                  : {},\n                paddingOut,\n                {\n                  ...font,\n                  fontSize,\n                  fontWeight,\n                  color: inputTextColor,\n                  textAlignVertical: multiline ? 'top' : 'center',\n                  textAlign: textAlign\n                    ? textAlign\n                    : I18nManager.isRTL\n                    ? 'right'\n                    : 'left',\n                },\n                Platform.OS === 'web' && { outline: 'none' },\n                adornmentStyleAdjustmentForNativeInput,\n              ],\n            } as RenderProps)}\n          </View>\n          <TextInputAdornment {...adornmentProps} />\n        </View>\n      </View>\n    );\n  }\n}\n\nexport default TextInputOutlined;\n\ntype OutlineProps = {\n  activeColor: string;\n  hasActiveOutline?: boolean;\n  outlineColor?: string;\n  backgroundColor: ColorValue;\n  theme: ReactNativePaper.Theme;\n};\n\nconst Outline = ({\n  theme,\n  hasActiveOutline,\n  activeColor,\n  outlineColor,\n  backgroundColor,\n}: OutlineProps) => (\n  <View\n    pointerEvents=\"none\"\n    style={[\n      styles.outline,\n      // eslint-disable-next-line react-native/no-inline-styles\n      {\n        backgroundColor,\n        borderRadius: theme.roundness,\n        borderWidth: hasActiveOutline ? 2 : 1,\n        borderColor: hasActiveOutline ? activeColor : outlineColor,\n      },\n    ]}\n  />\n);\n\nconst styles = StyleSheet.create({\n  placeholder: {\n    position: 'absolute',\n    left: 0,\n    paddingHorizontal: INPUT_PADDING_HORIZONTAL,\n  },\n  outline: {\n    position: 'absolute',\n    left: 0,\n    right: 0,\n    top: 6,\n    bottom: 0,\n  },\n  labelContainer: {\n    paddingBottom: 0,\n  },\n  input: {\n    flexGrow: 1,\n    paddingHorizontal: INPUT_PADDING_HORIZONTAL,\n    margin: 0,\n    zIndex: 1,\n  },\n  inputOutlined: {\n    paddingTop: 8,\n    paddingBottom: 8,\n  },\n  inputOutlinedDense: {\n    paddingTop: 4,\n    paddingBottom: 4,\n  },\n});\n","import * as React from 'react';\nimport {\n  View,\n  Animated,\n  TextInput as NativeTextInput,\n  StyleSheet,\n  I18nManager,\n  Platform,\n  TextStyle,\n} from 'react-native';\nimport color from 'color';\nimport InputLabel from './Label/InputLabel';\nimport TextInputAdornment, {\n  TextInputAdornmentProps,\n} from './Adornment/TextInputAdornment';\nimport type { RenderProps, ChildTextInputProps } from './types';\n\nimport {\n  MAXIMIZED_LABEL_FONT_SIZE,\n  MINIMIZED_LABEL_FONT_SIZE,\n  LABEL_WIGGLE_X_OFFSET,\n  ADORNMENT_SIZE,\n  FLAT_INPUT_OFFSET,\n} from './constants';\n\nimport {\n  calculateLabelTopPosition,\n  calculateInputHeight,\n  calculatePadding,\n  adjustPaddingFlat,\n  Padding,\n  interpolatePlaceholder,\n  calculateFlatAffixTopPosition,\n  calculateFlatInputHorizontalPadding,\n} from './helpers';\nimport {\n  getAdornmentConfig,\n  getAdornmentStyleAdjustmentForNativeInput,\n} from './Adornment/TextInputAdornment';\nimport { AdornmentSide, AdornmentType, InputMode } from './Adornment/enums';\n\nconst MINIMIZED_LABEL_Y_OFFSET = -18;\n\nconst LABEL_PADDING_TOP = 30;\nconst LABEL_PADDING_TOP_DENSE = 24;\nconst MIN_HEIGHT = 64;\nconst MIN_DENSE_HEIGHT_WL = 52;\nconst MIN_DENSE_HEIGHT = 40;\n\nclass TextInputFlat extends React.Component<ChildTextInputProps> {\n  static defaultProps = {\n    disabled: false,\n    error: false,\n    multiline: false,\n    editable: true,\n    render: (props: RenderProps) => <NativeTextInput {...props} />,\n  };\n\n  render() {\n    const {\n      disabled,\n      editable,\n      label,\n      error,\n      selectionColor,\n      underlineColor,\n      dense,\n      style,\n      theme,\n      render,\n      multiline,\n      parentState,\n      innerRef,\n      onFocus,\n      forceFocus,\n      onBlur,\n      onChangeText,\n      onLayoutAnimatedText,\n      onLeftAffixLayoutChange,\n      onRightAffixLayoutChange,\n      left,\n      right,\n      placeholderTextColor,\n      ...rest\n    } = this.props;\n\n    const { colors, fonts } = theme;\n    const font = fonts.regular;\n    const hasActiveOutline = parentState.focused || error;\n\n    const {\n      fontSize: fontSizeStyle,\n      fontWeight,\n      height,\n      paddingHorizontal,\n      textAlign,\n      ...viewStyle\n    } = (StyleSheet.flatten(style) || {}) as TextStyle;\n    const fontSize = fontSizeStyle || MAXIMIZED_LABEL_FONT_SIZE;\n\n    const isPaddingHorizontalPassed =\n      paddingHorizontal !== undefined && typeof paddingHorizontal === 'number';\n\n    const adornmentConfig = getAdornmentConfig({\n      left,\n      right,\n    });\n\n    let { paddingLeft, paddingRight } = calculateFlatInputHorizontalPadding({\n      adornmentConfig,\n    });\n\n    if (isPaddingHorizontalPassed) {\n      paddingLeft = paddingHorizontal as number;\n      paddingRight = paddingHorizontal as number;\n    }\n\n    const { leftLayout, rightLayout } = parentState;\n\n    const rightAffixWidth = right\n      ? rightLayout.width || ADORNMENT_SIZE\n      : ADORNMENT_SIZE;\n\n    const leftAffixWidth = left\n      ? leftLayout.width || ADORNMENT_SIZE\n      : ADORNMENT_SIZE;\n\n    const adornmentStyleAdjustmentForNativeInput = getAdornmentStyleAdjustmentForNativeInput(\n      {\n        adornmentConfig,\n        rightAffixWidth,\n        leftAffixWidth,\n        paddingHorizontal,\n        inputOffset: FLAT_INPUT_OFFSET,\n        mode: InputMode.Flat,\n      }\n    );\n\n    let inputTextColor,\n      activeColor,\n      underlineColorCustom,\n      placeholderColor,\n      errorColor;\n\n    if (disabled) {\n      inputTextColor = activeColor = color(colors.text)\n        .alpha(0.54)\n        .rgb()\n        .string();\n      placeholderColor = colors.disabled;\n      underlineColorCustom = 'transparent';\n    } else {\n      inputTextColor = colors.text;\n      activeColor = error ? colors.error : colors.primary;\n      placeholderColor = colors.placeholder;\n      errorColor = colors.error;\n      underlineColorCustom = underlineColor || colors.disabled;\n    }\n\n    const containerStyle = {\n      backgroundColor: theme.dark\n        ? color(colors.background).lighten(0.24).rgb().string()\n        : color(colors.background).darken(0.06).rgb().string(),\n      borderTopLeftRadius: theme.roundness,\n      borderTopRightRadius: theme.roundness,\n    };\n\n    const labelScale = MINIMIZED_LABEL_FONT_SIZE / fontSize;\n    const fontScale = MAXIMIZED_LABEL_FONT_SIZE / fontSize;\n\n    const labelWidth = parentState.labelLayout.width;\n    const labelHeight = parentState.labelLayout.height;\n    const labelHalfWidth = labelWidth / 2;\n    const labelHalfHeight = labelHeight / 2;\n\n    const baseLabelTranslateX =\n      (I18nManager.isRTL ? 1 : -1) *\n        (labelHalfWidth - (labelScale * labelWidth) / 2) +\n      (1 - labelScale) * (I18nManager.isRTL ? -1 : 1) * paddingLeft;\n\n    const minInputHeight = dense\n      ? (label ? MIN_DENSE_HEIGHT_WL : MIN_DENSE_HEIGHT) -\n        LABEL_PADDING_TOP_DENSE\n      : MIN_HEIGHT - LABEL_PADDING_TOP;\n\n    const inputHeight = calculateInputHeight(\n      labelHeight,\n      height,\n      minInputHeight\n    );\n\n    const topPosition = calculateLabelTopPosition(\n      labelHeight,\n      inputHeight,\n      multiline && height ? 0 : !height ? minInputHeight / 2 : 0\n    );\n\n    if (height && typeof height !== 'number') {\n      // eslint-disable-next-line\n      console.warn('Currently we support only numbers in height prop');\n    }\n\n    const paddingSettings = {\n      height: height ? +height : null,\n      labelHalfHeight,\n      offset: FLAT_INPUT_OFFSET,\n      multiline: multiline ? multiline : null,\n      dense: dense ? dense : null,\n      topPosition,\n      fontSize,\n      label,\n      scale: fontScale,\n      isAndroid: Platform.OS === 'android',\n      styles: StyleSheet.flatten(\n        dense ? styles.inputFlatDense : styles.inputFlat\n      ) as Padding,\n    };\n\n    const pad = calculatePadding(paddingSettings);\n\n    const paddingFlat = adjustPaddingFlat({\n      ...paddingSettings,\n      pad,\n    });\n\n    const baseLabelTranslateY =\n      -labelHalfHeight - (topPosition + MINIMIZED_LABEL_Y_OFFSET);\n\n    const placeholderOpacity = hasActiveOutline\n      ? interpolatePlaceholder(parentState.labeled, hasActiveOutline)\n      : parentState.labelLayout.measured\n      ? 1\n      : 0;\n\n    const minHeight =\n      height ||\n      (dense ? (label ? MIN_DENSE_HEIGHT_WL : MIN_DENSE_HEIGHT) : MIN_HEIGHT);\n\n    const flatHeight =\n      inputHeight +\n      (!height ? (dense ? LABEL_PADDING_TOP_DENSE : LABEL_PADDING_TOP) : 0);\n\n    const iconTopPosition = (flatHeight - ADORNMENT_SIZE) / 2;\n\n    const leftAffixTopPosition = leftLayout.height\n      ? calculateFlatAffixTopPosition({\n          height: flatHeight,\n          ...paddingFlat,\n          affixHeight: leftLayout.height,\n        })\n      : null;\n\n    const rightAffixTopPosition = rightLayout.height\n      ? calculateFlatAffixTopPosition({\n          height: flatHeight,\n          ...paddingFlat,\n          affixHeight: rightLayout.height,\n        })\n      : null;\n\n    const labelProps = {\n      label,\n      onLayoutAnimatedText,\n      placeholderOpacity,\n      error,\n      placeholderStyle: styles.placeholder,\n      baseLabelTranslateY,\n      baseLabelTranslateX,\n      font,\n      fontSize,\n      fontWeight,\n      labelScale,\n      wiggleOffsetX: LABEL_WIGGLE_X_OFFSET,\n      topPosition,\n      paddingOffset: { paddingLeft, paddingRight },\n      hasActiveOutline,\n      activeColor,\n      placeholderColor,\n      errorColor,\n    };\n    const affixTopPosition = {\n      [AdornmentSide.Left]: leftAffixTopPosition,\n      [AdornmentSide.Right]: rightAffixTopPosition,\n    };\n    const onAffixChange = {\n      [AdornmentSide.Left]: onLeftAffixLayoutChange,\n      [AdornmentSide.Right]: onRightAffixLayoutChange,\n    };\n\n    let adornmentProps: TextInputAdornmentProps = {\n      paddingHorizontal,\n      adornmentConfig,\n      forceFocus,\n      topPosition: {\n        [AdornmentType.Affix]: affixTopPosition,\n        [AdornmentType.Icon]: iconTopPosition,\n      },\n      onAffixChange,\n      isTextInputFocused: this.props.parentState.focused,\n    };\n    if (adornmentConfig.length) {\n      adornmentProps = {\n        ...adornmentProps,\n        left,\n        right,\n        textStyle: { ...font, fontSize, fontWeight },\n        visible: this.props.parentState.labeled,\n      };\n    }\n\n    return (\n      <View style={[containerStyle, viewStyle]}>\n        <Underline\n          parentState={parentState}\n          underlineColorCustom={underlineColorCustom}\n          error={error}\n          colors={colors}\n          activeColor={activeColor}\n        />\n        <View\n          style={[\n            styles.labelContainer,\n            {\n              minHeight,\n            },\n          ]}\n        >\n          <InputLabel parentState={parentState} labelProps={labelProps} />\n          {render?.({\n            ...rest,\n            ref: innerRef,\n            onChangeText,\n            placeholder: label\n              ? parentState.placeholder\n              : this.props.placeholder,\n            placeholderTextColor: placeholderTextColor ?? placeholderColor,\n            editable: !disabled && editable,\n            selectionColor:\n              typeof selectionColor === 'undefined'\n                ? activeColor\n                : selectionColor,\n            onFocus,\n            onBlur,\n            underlineColorAndroid: 'transparent',\n            multiline,\n            style: [\n              styles.input,\n              { paddingLeft, paddingRight },\n              !multiline || (multiline && height) ? { height: flatHeight } : {},\n              paddingFlat,\n              {\n                ...font,\n                fontSize,\n                fontWeight,\n                color: inputTextColor,\n                textAlignVertical: multiline ? 'top' : 'center',\n                textAlign: textAlign\n                  ? textAlign\n                  : I18nManager.isRTL\n                  ? 'right'\n                  : 'left',\n              },\n              Platform.OS === 'web' && { outline: 'none' },\n              adornmentStyleAdjustmentForNativeInput,\n            ],\n          })}\n        </View>\n        <TextInputAdornment {...adornmentProps} />\n      </View>\n    );\n  }\n}\n\nexport default TextInputFlat;\n\ntype UnderlineProps = {\n  parentState: {\n    focused: boolean;\n  };\n  error?: boolean;\n  colors: {\n    error: string;\n  };\n  activeColor: string;\n  underlineColorCustom?: string;\n};\n\nconst Underline = ({\n  parentState,\n  error,\n  colors,\n  activeColor,\n  underlineColorCustom,\n}: UnderlineProps) => {\n  let backgroundColor = parentState.focused\n    ? activeColor\n    : underlineColorCustom;\n  if (error) backgroundColor = colors.error;\n  return (\n    <Animated.View\n      style={[\n        styles.underline,\n        {\n          backgroundColor,\n          // Underlines is thinner when input is not focused\n          transform: [{ scaleY: parentState.focused ? 1 : 0.5 }],\n        },\n      ]}\n    />\n  );\n};\n\nconst styles = StyleSheet.create({\n  placeholder: {\n    position: 'absolute',\n    left: 0,\n  },\n  underline: {\n    position: 'absolute',\n    left: 0,\n    right: 0,\n    bottom: 0,\n    height: 2,\n  },\n  labelContainer: {\n    paddingTop: 0,\n    paddingBottom: 0,\n  },\n  input: {\n    flexGrow: 1,\n    margin: 0,\n    zIndex: 1,\n  },\n  inputFlat: {\n    paddingTop: 24,\n    paddingBottom: 4,\n  },\n  inputFlatDense: {\n    paddingTop: 22,\n    paddingBottom: 2,\n  },\n});\n","import * as React from 'react';\nimport {\n  Animated,\n  TextInput as NativeTextInput,\n  Platform,\n  LayoutChangeEvent,\n  StyleProp,\n  TextStyle,\n} from 'react-native';\nimport TextInputOutlined from './TextInputOutlined';\nimport TextInputFlat from './TextInputFlat';\nimport TextInputIcon from './Adornment/TextInputIcon';\nimport TextInputAffix from './Adornment/TextInputAffix';\nimport { withTheme } from '../../core/theming';\nimport type { RenderProps, State } from './types';\nimport type { $Omit } from '../../types';\n\nconst BLUR_ANIMATION_DURATION = 180;\nconst FOCUS_ANIMATION_DURATION = 150;\n\nexport type TextInputProps = React.ComponentPropsWithRef<\n  typeof NativeTextInput\n> & {\n  /**\n   * Mode of the TextInput.\n   * - `flat` - flat input with an underline.\n   * - `outlined` - input with an outline.\n   *\n   * In `outlined` mode, the background color of the label is derived from `colors.background` in theme or the `backgroundColor` style.\n   * This component render TextInputOutlined or TextInputFlat based on that props\n   */\n  mode?: 'flat' | 'outlined';\n  left?: React.ReactNode;\n  right?: React.ReactNode;\n  /**\n   * If true, user won't be able to interact with the component.\n   */\n  disabled?: boolean;\n  /**\n   * The text to use for the floating label.\n   */\n  label?: string;\n  /**\n   * Placeholder for the input.\n   */\n  placeholder?: string;\n  /**\n   * Whether to style the TextInput with error style.\n   */\n  error?: boolean;\n  /**\n   * Callback that is called when the text input's text changes. Changed text is passed as an argument to the callback handler.\n   */\n  onChangeText?: Function;\n  /**\n   * Selection color of the input\n   */\n  selectionColor?: string;\n  /**\n   * Underline color of the input.\n   */\n  underlineColor?: string;\n  /**\n   * Sets min height with densed layout. For `TextInput` in `flat` mode\n   * height is `64dp` or in dense layout - `52dp` with label or `40dp` without label.\n   * For `TextInput` in `outlined` mode\n   * height is `56dp` or in dense layout - `40dp` regardless of label.\n   * When you apply `heigh` prop in style the `dense` prop affects only `paddingVertical` inside `TextInput`\n   */\n  dense?: boolean;\n  /**\n   * Whether the input can have multiple lines.\n   */\n  multiline?: boolean;\n  /**\n   * The number of lines to show in the input (Android only).\n   */\n  numberOfLines?: number;\n  /**\n   * Callback that is called when the text input is focused.\n   */\n  onFocus?: (args: any) => void;\n  /**\n   * Callback that is called when the text input is blurred.\n   */\n  onBlur?: (args: any) => void;\n  /**\n   *\n   * Callback to render a custom input component such as `react-native-text-input-mask`\n   * instead of the default `TextInput` component from `react-native`.\n   *\n   * Example:\n   * ```js\n   * <TextInput\n   *   label=\"Phone number\"\n   *   render={props =>\n   *     <TextInputMask\n   *       {...props}\n   *       mask=\"+[00] [000] [000] [000]\"\n   *     />\n   *   }\n   * />\n   * ```\n   */\n  render?: (props: RenderProps) => React.ReactNode;\n  /**\n   * Value of the text input.\n   */\n  value?: string;\n  /**\n   * Pass `fontSize` prop to modify the font size inside `TextInput`.\n   * Pass `height` prop to set `TextInput` height. When `height` is passed,\n   * `dense` prop will affect only input's `paddingVertical`.\n   * Pass `paddingHorizontal` to modify horizontal padding.\n   * This can be used to get MD Guidelines v1 TextInput look.\n   */\n  style?: StyleProp<TextStyle>;\n  /**\n   * @optional\n   */\n  theme: ReactNativePaper.Theme;\n};\n\n/**\n * A component to allow users to input text.\n *\n * <div class=\"screenshots\">\n *   <figure>\n *     <img class=\"medium\" src=\"screenshots/textinput-flat.focused.png\" />\n *     <figcaption>Flat (focused)</figcaption>\n *   </figure>\n *   <figure>\n *     <img class=\"medium\" src=\"screenshots/textinput-flat.disabled.png\" />\n *     <figcaption>Flat (disabled)</figcaption>\n *   </figure>\n *   <figure>\n *     <img class=\"medium\" src=\"screenshots/textinput-outlined.focused.png\" />\n *     <figcaption>Outlined (focused)</figcaption>\n *   </figure>\n *   <figure>\n *     <img class=\"medium\" src=\"screenshots/textinput-outlined.disabled.png\" />\n *     <figcaption>Outlined (disabled)</figcaption>\n *   </figure>\n * </div>\n *\n * ## Usage\n * ```js\n * import * as React from 'react';\n * import { TextInput } from 'react-native-paper';\n *\n * const MyComponent = () => {\n *   const [text, setText] = React.useState('');\n *\n *   return (\n *     <TextInput\n *       label=\"Email\"\n *       value={text}\n *       onChangeText={text => setText(text)}\n *     />\n *   );\n * };\n *\n * export default MyComponent;\n * ```\n *\n * @extends TextInput props https://reactnative.dev/docs/textinput#props\n */\n\nclass TextInput extends React.Component<TextInputProps, State> {\n  // @component ./Adornment/TextInputIcon.tsx\n  static Icon = TextInputIcon;\n\n  // @component ./Adornment/TextInputAffix.tsx\n  static Affix = TextInputAffix;\n\n  static defaultProps: Partial<TextInputProps> = {\n    mode: 'flat',\n    dense: false,\n    disabled: false,\n    error: false,\n    multiline: false,\n    editable: true,\n    render: (props: RenderProps) => <NativeTextInput {...props} />,\n  };\n\n  static getDerivedStateFromProps(nextProps: TextInputProps, prevState: State) {\n    return {\n      value:\n        typeof nextProps.value !== 'undefined'\n          ? nextProps.value\n          : prevState.value,\n    };\n  }\n  validInputValue =\n    this.props.value !== undefined ? this.props.value : this.props.defaultValue;\n\n  state = {\n    labeled: new Animated.Value(this.validInputValue ? 0 : 1),\n    error: new Animated.Value(this.props.error ? 1 : 0),\n    focused: false,\n    placeholder: '',\n    value: this.validInputValue,\n    labelLayout: {\n      measured: false,\n      width: 0,\n      height: 0,\n    },\n    leftLayout: {\n      width: null,\n      height: null,\n    },\n    rightLayout: {\n      width: null,\n      height: null,\n    },\n  };\n\n  ref: NativeTextInput | undefined | null;\n\n  componentDidUpdate(prevProps: TextInputProps, prevState: State) {\n    const isFocusChanged = prevState.focused !== this.state.focused;\n    const isValueChanged = prevState.value !== this.state.value;\n    const isLabelLayoutChanged =\n      prevState.labelLayout !== this.state.labelLayout;\n    const isLabelChanged = prevProps.label !== this.props.label;\n    const isErrorChanged = prevProps.error !== this.props.error;\n\n    if (\n      isFocusChanged ||\n      isValueChanged ||\n      // workaround for animated regression for react native > 0.61\n      // https://github.com/callstack/react-native-paper/pull/1440\n      isLabelLayoutChanged\n    ) {\n      // The label should be minimized if the text input is focused, or has text\n      // In minimized mode, the label moves up and becomes small\n      if (this.state.value || this.state.focused) {\n        this.minimizeLabel();\n      } else {\n        this.restoreLabel();\n      }\n    }\n\n    if (isFocusChanged || isLabelChanged) {\n      // Show placeholder text only if the input is focused, or there's no label\n      // We don't show placeholder if there's a label because the label acts as placeholder\n      // When focused, the label moves up, so we can show a placeholder\n      if (this.state.focused || !this.props.label) {\n        this.showPlaceholder();\n      } else {\n        this.hidePlaceholder();\n      }\n    }\n\n    if (isErrorChanged) {\n      // When the input has an error, we wiggle the label and apply error styles\n      if (this.props.error) {\n        this.showError();\n      } else {\n        this.hideError();\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n  }\n\n  private showPlaceholder = () => {\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n\n    // Set the placeholder in a delay to offset the label animation\n    // If we show it immediately, they'll overlap and look ugly\n    this.timer = (setTimeout(\n      () =>\n        this.setState({\n          placeholder: this.props.placeholder,\n        }),\n      50\n    ) as unknown) as NodeJS.Timeout;\n  };\n\n  private hidePlaceholder = () =>\n    this.setState({\n      placeholder: '',\n    });\n\n  private timer?: NodeJS.Timeout;\n  private root: NativeTextInput | undefined | null;\n\n  private showError = () => {\n    const { scale } = this.props.theme.animation;\n    Animated.timing(this.state.error, {\n      toValue: 1,\n      duration: FOCUS_ANIMATION_DURATION * scale,\n      // To prevent this - https://github.com/callstack/react-native-paper/issues/941\n      useNativeDriver: Platform.select({\n        ios: false,\n        default: true,\n      }),\n    }).start();\n  };\n\n  private hideError = () => {\n    const { scale } = this.props.theme.animation;\n    Animated.timing(this.state.error, {\n      toValue: 0,\n      duration: BLUR_ANIMATION_DURATION * scale,\n      // To prevent this - https://github.com/callstack/react-native-paper/issues/941\n      useNativeDriver: Platform.select({\n        ios: false,\n        default: true,\n      }),\n    }).start();\n  };\n\n  private restoreLabel = () => {\n    const { scale } = this.props.theme.animation;\n    Animated.timing(this.state.labeled, {\n      toValue: 1,\n      duration: FOCUS_ANIMATION_DURATION * scale,\n      // To prevent this - https://github.com/callstack/react-native-paper/issues/941\n      useNativeDriver: Platform.select({\n        ios: false,\n        default: true,\n      }),\n    }).start();\n  };\n\n  private minimizeLabel = () => {\n    const { scale } = this.props.theme.animation;\n    Animated.timing(this.state.labeled, {\n      toValue: 0,\n      duration: BLUR_ANIMATION_DURATION * scale,\n      // To prevent this - https://github.com/callstack/react-native-paper/issues/941\n      useNativeDriver: Platform.select({\n        ios: false,\n        default: true,\n      }),\n    }).start();\n  };\n\n  private onLeftAffixLayoutChange = (event: LayoutChangeEvent) => {\n    this.setState({\n      leftLayout: {\n        height: event.nativeEvent.layout.height,\n        width: event.nativeEvent.layout.width,\n      },\n    });\n  };\n\n  private onRightAffixLayoutChange = (event: LayoutChangeEvent) => {\n    this.setState({\n      rightLayout: {\n        width: event.nativeEvent.layout.width,\n        height: event.nativeEvent.layout.height,\n      },\n    });\n  };\n\n  private handleFocus = (args: any) => {\n    if (this.props.disabled || !this.props.editable) {\n      return;\n    }\n\n    this.setState({ focused: true });\n\n    if (this.props.onFocus) {\n      this.props.onFocus(args);\n    }\n  };\n\n  private handleBlur = (args: Object) => {\n    if (!this.props.editable) {\n      return;\n    }\n\n    this.setState({ focused: false });\n\n    if (this.props.onBlur) {\n      this.props.onBlur(args);\n    }\n  };\n\n  private handleChangeText = (value: string) => {\n    if (!this.props.editable) {\n      return;\n    }\n\n    this.setState({ value });\n    this.props.onChangeText && this.props.onChangeText(value);\n  };\n\n  private handleLayoutAnimatedText = (e: LayoutChangeEvent) => {\n    this.setState({\n      labelLayout: {\n        width: e.nativeEvent.layout.width,\n        height: e.nativeEvent.layout.height,\n        measured: true,\n      },\n    });\n  };\n\n  forceFocus = () => {\n    return this.root?.focus();\n  };\n\n  /**\n   * @internal\n   */\n  setNativeProps(args: Object) {\n    return this.root && this.root.setNativeProps(args);\n  }\n\n  /**\n   * Returns `true` if the input is currently focused, `false` otherwise.\n   */\n  isFocused() {\n    return this.root && this.root.isFocused();\n  }\n\n  /**\n   * Removes all text from the TextInput.\n   */\n  clear() {\n    return this.root && this.root.clear();\n  }\n\n  /**\n   * Focuses the input.\n   */\n  focus() {\n    return this.root && this.root.focus();\n  }\n\n  /**\n   * Removes focus from the input.\n   */\n  blur() {\n    return this.root && this.root.blur();\n  }\n  render() {\n    const { mode, ...rest } = this.props as $Omit<TextInputProps, 'ref'>;\n\n    return mode === 'outlined' ? (\n      <TextInputOutlined\n        {...rest}\n        value={this.state.value}\n        parentState={this.state}\n        innerRef={(ref) => {\n          this.root = ref;\n        }}\n        onFocus={this.handleFocus}\n        forceFocus={this.forceFocus}\n        onBlur={this.handleBlur}\n        onChangeText={this.handleChangeText}\n        onLayoutAnimatedText={this.handleLayoutAnimatedText}\n        onLeftAffixLayoutChange={this.onLeftAffixLayoutChange}\n        onRightAffixLayoutChange={this.onRightAffixLayoutChange}\n      />\n    ) : (\n      <TextInputFlat\n        {...rest}\n        value={this.state.value}\n        parentState={this.state}\n        innerRef={(ref) => {\n          this.root = ref;\n        }}\n        onFocus={this.handleFocus}\n        forceFocus={this.forceFocus}\n        onBlur={this.handleBlur}\n        onChangeText={this.handleChangeText}\n        onLayoutAnimatedText={this.handleLayoutAnimatedText}\n        onLeftAffixLayoutChange={this.onLeftAffixLayoutChange}\n        onRightAffixLayoutChange={this.onRightAffixLayoutChange}\n      />\n    );\n  }\n}\n\nexport default withTheme(TextInput);\n","import * as React from 'react';\nimport {\n  Animated,\n  TextStyle,\n  I18nManager,\n  StyleProp,\n  StyleSheet,\n} from 'react-native';\nimport { withTheme } from '../../core/theming';\n\ntype Props = React.ComponentPropsWithRef<typeof Animated.Text> & {\n  style?: StyleProp<TextStyle>;\n  /**\n   * @optional\n   */\n  theme: ReactNativePaper.Theme;\n};\n\n/**\n * Text component which follows styles from the theme.\n *\n * @extends Text props https://reactnative.dev/docs/text#props\n */\nfunction AnimatedText({ style, theme, ...rest }: Props) {\n  const writingDirection = I18nManager.isRTL ? 'rtl' : 'ltr';\n\n  return (\n    <Animated.Text\n      {...rest}\n      style={[\n        styles.text,\n        {\n          ...theme.fonts.regular,\n          color: theme.colors.text,\n          writingDirection,\n        },\n        style,\n      ]}\n    />\n  );\n}\n\nconst styles = StyleSheet.create({\n  text: {\n    textAlign: 'left',\n  },\n});\n\nexport default withTheme(AnimatedText);\n"],"sourceRoot":""}